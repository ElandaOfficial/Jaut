#[=================================================================================================================[.rst
csv
---------

.. contents::

Overview
^^^^^^^^

This module allows CMake to read, write and manage CSV documents.
You can import documents from files and strings or write to files and output as strings.

Since there is no hard rules to how CSV documents should be interpreted, this module goes the most
general way for managing them.
It's important to note that there are still a few exceptional rules to how documents will be parsed:

- Empty lines, such as there is nothing but whitespace, will be completely ignored and
  not counted as a record with all fields empty.
- | Since this parser works on a per-line basis, quoted strings can not journey over several lines.
  | If a quoted string is unterminated at the end of a line, this is a hard error.

Aside from that, you will also be able to create new documents from scratch as well as manipulating them whatever way you like.
And, of course, write them to disk.

Commands
^^^^^^^^

Overview
""""""""

.. parsed-literal::

  `Document`_
    csv(`IMPORT`_ <prefix> <FILE file | STRING input> [HEADER {NORMAL | PARSE | IGNORE}] [STRICT])
    csv(`EXPORT`_ <prefix> <FILE file | STRING out-var> [HEADER {EXCLUDE | INCLUDE}])
    csv(`CREATE`_ <prefix>)
    csv(`DELETE`_ <prefix>)

  `Reading`_
    csv(`GET`_ <prefix> <out-var> [RECORD <ordinal>] [COLUMN <ordinal>])
    csv(`GET_HEADER`_ <prefix> <ordinal> <out-var>)

  `Manipulation`_
    csv(`REMOVE`_ <prefix> [RECORD <ordinal>] [COLUMN <ordinal>] [OUTPUT_VARIABLE <out-var>])
    csv(`SET`_ <prefix> <record-ordinal> <column-ordinal> <value>)
    csv(`INSERT RECORD`_ <prefix> [POSITION <ordinal>] [VALUES <value>...] [FILL value])
    csv(`INSERT COLUMN`_ <prefix> [POSITION <index>] [HEADER <name>] [VALUES <value>...] [FILL value])
    csv(`MOVE RECORD`_ <prefix> <ordinal> <UP [amount] | DOWN [amount] | POSITION ordinal>)
    csv(`MOVE COLUMN`_ <prefix> <ordinal> <LEFT [amount] | RIGHT [amount] | POSITION ordinal>)
    csv(`SET_HEADER`_ <prefix> <ordinal> <header-name>)

Document
""""""""

.. _IMPORT:

.. code-block:: cmake

    csv(IMPORT <prefix>
        {FILE <file> | STRING <input>}
        [HEADER {NORMAL | PARSE | IGNORE}]
        [STRICT])

Imports a CSV document from either a string ``<input>`` or from a file ``<file>`` and parses the input to a CSV document.

If ``STRICT`` is specified, the parser will only parse CSV files following these guidelines:

- Records can not have variable amounts of columns

The ``HEADER`` options allows to parse the column headers of a CSV input in 3 different ways:

- | ``NORMAL``
  | This is the default mode if ``HEADER`` was not specified.
  | In this mode, the first line of a CSV document will be parsed as a normal record.
  | The headers generated will be numbered from 0 to N.
- | ``PARSE``
  | In this mode, the first line will be treated as a header line, meaning, all columns will be mapped
  | to their respective columns in the following records.
  | If any of the headers is missing, the header will be numbered based on its significance.
- | ``IGNORE``
  | In this mode, the first line of the document will be ignored and will not be parsed as a record.
  | The headers generated will be numbered from 0 to N.

The following variables will be auto-generated by this call:

- | ``<prefix>_DOCUMENT``
  | A list containing all variable names for each record
- | ``<prefix>_COLUMN_COUNT``
  | The number of columns this document delivers
- | ``<prefix>_HEADERS``
  | The header names for this document
- | ``<prefix>_RECORD_<N>``
  | The variable for each record generated; where `<N>` is the ordinal of the record

In addition to these, a global property will be created.
This property is called ``es_csv_parser_document_list``, which will hold a list of all parsed/created CSV document prefixes.

.. _EXPORT:

.. code-block:: cmake

    csv(EXPORT <prefix>
        {FILE <file> | STRING <out-var>}
        [HEADER {EXCLUDE | INCLUDE}])

Exports the document with the specified ``<prefix>`` (if it exists, otherwise error), either to a file ``<file>`` or to
an output variable ``<out-var>`` as string.

The ``HEADER`` option specifies how column headers should be treated in the output:

- | ``EXCLUDE``
  | This is the default mode if ``HEADER`` was not specified.
  | In this mode, the headers won't be recorded as first line.
- | ``INCLUDE``
  | In this mode, the headers will be recorded as first line.

.. _CREATE:

.. code-block:: cmake

    csv(CREATE <prefix>)

Creates a new empty CSV document.
This effectively just registers the prefix and creates the same variables as `IMPORT`_.

.. _DELETE:

.. code-block:: cmake

    csv(DELETE <prefix>)

| Deletes an existing document, if no such document exists an error will occur.
| This will also unset all variables created by one of the document creation operations.

Reading
"""""""

.. _GET:

.. code-block:: cmake

    csv(GET <prefix> <out-var>
        [RECORD <ordinal>]
        [COLUMN <ordinal>])

Gets an entity from the specified CSV document for ``<prefix>`` and sets ``<out-var>`` to the found value.
Numbers are not 0- but ordinal-based.

If ``RECORD`` and ``COLUMN`` are both specified, this function gives back the exact field in the specified record.
If only ``RECORD`` is given, it will give back all fields from that record.
If only ``COLUMN`` is given, it will give back all fields from one column across all records.
If any of the two are out of bounds or none of the two are specified, an error will occur.

.. _GET_HEADER:

.. code-block:: cmake

    csv(GET_HEADER <prefix> <ordinal> <out-var>)
        Gets the header name from the given column at ``<ordinal>``.

Manipulation
""""""""""""

.. _REMOVE:

.. code-block:: cmake

    csv(REMOVE <prefix>
        [RECORD <ordinal>]
        [COLUMN <ordinal>]
        [OUTPUT_VARIABLE <out-var>])

Removes an entity from the CSV document for ``<prefix>``.

If ``RECORD`` and ``COLUMN`` are both specified, this function removes the exact field in the specified record. (this effectively means setting it to an empty string)
If only ``RECORD`` is given, it will remove the whole record.
If only ``COLUMN`` is given, it will remove the whole column from the document.
If any of the two are out of bounds or none of the two are specified, an error will occur.

``OUTPUT_VARIABLE``, if set, will give back the removed values following it, otherwise everything will be discarded.
If in column mode, the header will be prepended to the returned list as first element.

.. _SET:

.. code-block:: cmake

    csv(SET <prefix> <record-ordinal> <column-ordinal> <value>)

Sets a certain field from the specified CSV document for ``<prefix>`` to ``<value>``.

.. _INSERT RECORD:

.. _INSERT COLUMN:

.. code-block:: cmake

    csv(INSERT RECORD <prefix>
        [INDEX <index>]
        [VALUES <value>...]
        [FILL value])

.. code-block:: cmake

    csv(INSERT COLUMN <prefix>
        [INDEX <index>]
        [HEADER <name>]
        [VALUES <value>...]
        [FILL value])

Inserts either a new record or column into the CSV document for ``<prefix>``.

The optional ``INDEX`` argument lets you specify an ordinal, determining at what position to insert the given entity. If this ordinal is outside bounds however (except one past the end) an error will occur.
If this argument is not provided, it will insert at the end.

The optional ``VALUES`` list argument let's you specify elements that should be inserted into the entity's generated fields, starting from the first field. All values beyond the last field will be dropped.
If ``FILL`` is specified, this will fill all empty fields that are not given via ``VALUES`` with the value specified for ``FILL``, by default this will be an empty string.

For the ``COLUMN`` variant, the optional ``HEADER`` argument let's you specify a header name for the newly generated column. If left empty, it will be given a number based on its significance.

.. _MOVE RECORD:

.. _MOVE COLUMN:

.. code-block:: cmake

    csv(MOVE RECORD <prefix> <ordinal>
        <UP [amount] | DOWN [amount] | POSITION new-ordinal>)

.. code-block:: cmake

    csv(MOVE COLUMN <prefix> <ordinal>
        <LEFT [amount] | RIGHT [amount] | POSITION new-ordinal>)

Moves a record or column with the specified ``<ordinal>`` to the specified position.

| If ``UP``, ``DOWN``, ``LEFT`` or ``RIGHT`` is specified, will move the entity ``<amount>`` places into that direction. If no ``<amount>`` is specified, will move it once.
| If ``POSITION`` is specified, will move the entity to exactly that position. Entities further down the list will be shifted.

.. _SET_HEADER:

.. code-block:: cmake

    csv(SET_HEADER <prefix> <ordinal> <header-name>)

Sets the header name from at given column at ``<ordinal>``.

Examples
^^^^^^^^

Parsing a document
""""""""""""""""""

It is rather simple to parse a CSV document.
For the sake of this example we will parse a CSV file that looks like this (a list of language codes):

.. code-block:: ini

    aa,Afar
    ab,Abkhazian
    ae,Avestan
    af,Afrikaans
    ar,Arabic
    bg,Bulgarian
    bh,Bihari languages
    bi,Bislama
    bm,Bambara
    cs,Czech
    cu,Church Slavic; Old Slavonic; Church Slavonic; Old Bulgarian; Old Church Slavonic
    cv,Chuvash
    cy,Welsh
    da,Danish
    de,German
    dv,Divehi; Dhivehi; Maldivian
    dz,Dzongkha
    ee,Ewe
    el,"Greek, Modern (1453-)"

Now, thanks to this parser we can import this data for a prefix ``MY_DOCUMENT``:

.. code-block:: cmake

    csv(IMPORT MY_CSV_DOCUMENT FILE "${CMAKE_CURRENT_LIST_DIR}/languages.csv")

We can now access the parsed data as we like.
Of course, if we don't have a document to parse but want to work on an entirely new table, we can do so with ``CREATE``:

.. code-block:: cmake

    csv(CREATE MY_EMPTY_CSV_DOCUMENT)

This will create our new empty document.
And in case we don't want/need  a document anymore, we can delete them via:

.. code-block:: cmake

    csv(DELETE MY_CSV_DOCUMENT)

This is important if we want the chosen prefix to be available again.
#]=================================================================================================================]

########################################################################################################################
# HEADER
########################################################################################################################
include_guard(GLOBAL)
cmake_minimum_required(VERSION 3.22 FATAL_ERROR)



########################################################################################################################
# HELPERS
########################################################################################################################
# Check whether document prefix exists in the document-list property
macro(csv_internal_document_check)
    get_property(document_list GLOBAL
        PROPERTY es_csv_parser_document_list)

    if (NOT "${prefix}" IN_LIST document_list)
        message(FATAL_ERROR "There is no registered csv document for prefix '${prefix}'")
    endif()
endmacro()

# Check whether we have at least the required amount of needed arguments
function(csv_internal_need_at_least operation num min)
    if (${num} LESS ${min})
        math(EXPR needed "${min} - 1")
        message(FATAL_ERROR "Operation '${operation}' called with invalid amount of arguments, need at least ${needed}")
    endif()
endfunction()

# Create the list of values for a newly inserted record
function(csv_internal_INSERT_create_record values max_len out_var fill)
    list(SUBLIST values 0 ${max_len} value_list)
    list(LENGTH value_list value_len)

    set(compensate false)

    if (${value_len} EQUAL 0 AND NOT value_list_empty)
        set(value_len  1)
        set(compensate true)
    endif()

    if (${value_len} GREATER 0)
        if (${value_len} LESS ${max_len})
            math(EXPR needed "${max_len} - ${value_len}")

            foreach(i RANGE 1 ${needed})
                if (compensate)
                    if (${i} EQUAL 1)
                        continue()
                    endif()

                    set(value_list ";${fill}")
                    set(compensate false)
                endif()

                list(APPEND value_list "${fill}")
            endforeach()
        endif()

        set(${out_var} "${value_list}" PARENT_SCOPE)
    else()
        foreach(i RANGE 1 ${${prefix}_COLUMN_COUNT})
            if (${i} EQUAL 1)
                set(new_record "${fill}")
                continue()
            endif()

            string(APPEND new_record ";${fill}")
        endforeach()

        set(${out_var} "${new_record}" PARENT_SCOPE)
    endif()
endfunction()

# Gets a record as output text
function(csv_internal_format_record record_text out_var)
    list(LENGTH record_text out_len)
    math(EXPR out_last_index "${out_len} - 1")

    foreach(i RANGE ${out_last_index})
        list(GET record_text ${i} element)

        string(FIND "${element}" ","  comma_pos)
        string(FIND "${element}" "\"" quote_pos)

        string(REPLACE "\"" "\"\"" element "${element}")

        if (${comma_pos} GREATER -1 OR ${quote_pos} GREATER -1)
            set(element "\"${element}\"")
        endif()

        string(APPEND text "${element}")

        if (NOT ${i} EQUAL ${out_last_index})
            string(APPEND text ",")
        endif()
    endforeach()

    set(${out_var} "${text}\n" PARENT_SCOPE)
endfunction()



########################################################################################################################
# ITERATOR
########################################################################################################################
function(throw_if_invalid operation total start expected)
    math(EXPR out_args "${total} - ${start}")

    if (NOT ${out_args} EQUAL expected)
        message(FATAL_ERROR "Invalid amount of arguments for operation ${operation}, ${expected} expected")
    endif()
endfunction()

function(iterator_internal_extract iterator out_pos out_var)
    string(FIND "${${iterator}}" "=" it_sep_pos)

    if (${it_sep_pos} EQUAL -1)
        message(FATAL_ERROR "Iterator '${iterator}' is not a valid iterator")
    endif()

    string(SUBSTRING "${${iterator}}" 0 ${it_sep_pos} it_pos)

    if (NOT "${it_pos}" MATCHES "[0]|[1-9][0-9]*")
        message(FATAL_ERROR "Iterator '${iterator}' is not a valid iterator")
    endif()

    math(EXPR it_sep_pos "${it_sep_pos} + 1")
    string(SUBSTRING "${${iterator}}" ${it_sep_pos} -1 it_var)

    set(${out_pos} ${it_pos} PARENT_SCOPE)
    set(${out_var} ${it_var} PARENT_SCOPE)
endfunction()

########################################################################################################################
# Creates a new iterator
# iterator(CREATE <iterator> <string-var>)
#
# Deletes an old iterator
# iterator(DELETE <iterator>)
#
# Get current/next/previous char (or <iterator>-NOTFOUND if invalid iterator)
# iterator(GET [NEXT|PREV] <iterator> <out-var> [SKIP])
#
# Iterate to next or previous
# iterator(<INC|DEC> <iterator> [amount])
#
# Gets a property about a certain iterator (or <iterator>-NOTFOUND if invalid iterator)
# iterator(PROPERTY <CONTENT|LENGTH|CHAR_LIST|POS> <iterator> <out-var>)
#
# Gets the end position of this iterator
# iterator(END <iterator> <out-var>)
#
# Skips until the first non whitespace character
# iterator(SKIP_WHITESPACE <iterator>)
#
# Skips the iterator until a certain char is found
# iterator(SKIP_UNTIL <iterator> <expected> [REVERSE])
#
# Gets the string that precedes the current iterator position
# iterator(PREFIX <iterator> <out-var>)
#
# Gets the string from the current iterator position to the end of the string
# iterator(SUFFIX <iterator> <out-var>)
function(iterator)
    if ("${ARGV0}" STREQUAL "CREATE")
        throw_if_invalid(CREATE ${ARGC} 1 2)

        set(iterator_name "${ARGV1}")
        list(FIND ITERATOR_LIST "${iterator_name}" index)

        if (${index} GREATER -1)
            return()
        endif()

        list(APPEND ITERATOR_LIST "${iterator_name}")
        set(ITERATOR_LIST ${ITERATOR_LIST} PARENT_SCOPE)

        set(${iterator_name} "0=${ARGV2}" PARENT_SCOPE)
    elseif ("${ARGV0}" STREQUAL "DELETE")
        throw_if_invalid(DELETE ${ARGC} 1 1)

        set(iterator_name "${ARGV1}")
        list(FIND ITERATOR_LIST "${iterator_name}" index)

        if (${index} EQUAL -1)
            message(FATAL_ERROR "Iterator ${iterator_name} not found")
        endif()

        list(REMOVE_ITEM ITERATOR_LIST ${iterator_name})
        set(ITERATOR_LIST ${ITERATOR_LIST} PARENT_SCOPE)
        unset(${iterator_name} PARENT_SCOPE)
    elseif ("${ARGV0}" STREQUAL "GET")
        if (NOT "${ARGV1}" STREQUAL "NEXT" AND NOT "${ARGV1}" STREQUAL "PREV")
            set(iterator_name "${ARGV1}")
        else()
            set(iterator_name "${ARGV2}")
        endif()

        list(FIND ITERATOR_LIST "${iterator_name}" index)

        if (${index} EQUAL -1)
            message(FATAL_ERROR "Iterator ${iterator_name} not found")
        endif()

        iterator_internal_extract(${iterator_name} it_pos it_var)
        set(skip_to_index FALSE)

        if ("${ARGV1}" STREQUAL "NEXT")
            math(EXPR it_index "${it_pos} + 1")

            if ("${ARGV4}" STREQUAL "SKIP")
                set(skip_to_index TRUE)
            endif()

            set(it_out ${ARGV3})
        elseif("${ARGV1}" STREQUAL "PREV")
            math(EXPR it_index "${it_pos} - 1")

            if ("${ARGV4}" STREQUAL "SKIP")
                set(skip_to_index TRUE)
            endif()

            set(it_out ${ARGV3})
        else()
            set(it_index ${it_pos})
            set(it_out   ${ARGV2})
        endif()

        string(LENGTH "${${it_var}}" content_len)

        if (${it_index} LESS 0 OR ${it_index} GREATER ${content_len})
            message(FATAL_ERROR "Iterator ${iterator_name} index out of bounds: ${it_index}")
        endif()

        string(SUBSTRING "${${it_var}}" ${it_index} 1 out_char)

        if (${it_index} EQUAL ${content_len})
            set(${it_out} "EOL" PARENT_SCOPE)
        else()
            set(${it_out} "${out_char}" PARENT_SCOPE)
        endif()

        if (skip_to_index)
            set(${iterator_name} "${it_index}=${it_var}" PARENT_SCOPE)
        endif()
    elseif("${ARGV0}" STREQUAL "INC" OR "${ARGV0}" STREQUAL "DEC")
        if (${ARGC} LESS 2 OR ${ARGC} GREATER 3)
            message(FATAL_ERROR "Invalid amount of arguments for operation ${ARGV0}, expected either 1 or 2")
        endif()

        set(iterator_name "${ARGV1}")
        list(FIND ITERATOR_LIST "${iterator_name}" index)

        if (${index} EQUAL -1)
            message(FATAL_ERROR "Iterator ${iterator_name} not found")
        endif()

        set(amount 1)

        if (${ARGC} GREATER 2)
            set(amount ${ARGV2})

            if (NOT "${ARGV2}" MATCHES "[1-9][0-9]*")
                message(FATAL_ERROR "Invalid increment/decrement amount ${ARGV2}")
            endif()
        endif()

        iterator_internal_extract(${iterator_name} it_pos it_var)

        if ("${ARGV0}" STREQUAL "INC")
            math(EXPR new_it "${it_pos} + ${amount}")
        else()
            math(EXPR new_it "${it_pos} - ${amount}")
        endif()

        string(LENGTH "${${it_var}}" out_len)

        if (${new_it} LESS 0 OR ${new_it} GREATER ${out_len})
            message(FATAL_ERROR "Iterator ${iterator_name} index out of bounds: ${new_it}")
        endif()

        set(${iterator_name} "${new_it}=${it_var}" PARENT_SCOPE)
    elseif("${ARGV0}" STREQUAL "PROPERTY")
        throw_if_invalid(PROPERTY ${ARGC} 1 3)

        set(iterator_name "${ARGV2}")
        list(FIND ITERATOR_LIST "${iterator_name}" index)

        if (${index} EQUAL -1)
            message(FATAL_ERROR "Iterator ${iterator_name} not found")
        endif()

        iterator_internal_extract(${iterator_name} it_pos it_var)

        if ("${ARGV1}" STREQUAL "CONTENT")
            set(${ARGV3} "${${it_var}}" PARENT_SCOPE)
        elseif("${ARGV1}" STREQUAL "LENGTH")
            string(LENGTH "${${it_var}}" out_len)
            set(${ARGV3} "${out_len}" PARENT_SCOPE)
        elseif("${ARGV1}" STREQUAL "CHAR_LIST")
            string(LENGTH "${${it_var}}" out_len)
            math(EXPR out_last_index "${out_len} - 1")

            foreach(i RANGE ${out_last_index})
                string(SUBSTRING "${${it_var}}" ${i} 1 out_char)
                list(APPEND char_list "${out_char}")
            endforeach()

            set(${ARGV3} ${char_list} PARENT_SCOPE)
        elseif("${ARGV1}" STREQUAL "POS")
            set(${ARGV3} ${it_pos} PARENT_SCOPE)
        else()
            message(FATAL_ERROR "Invalid property '${ARGV1}")
        endif()
    elseif("${ARGV0}" STREQUAL "END")
        throw_if_invalid(END ${ARGC} 1 2)

        set(iterator_name "${ARGV1}")
        list(FIND ITERATOR_LIST "${iterator_name}" index)

        if (${index} EQUAL -1)
            set(${ARGV2} "${iterator_name}-NOTFOUND" PARENT_SCOPE)
            return()
        endif()

        iterator_internal_extract(${iterator_name} it_pos it_var)

        string(LENGTH "${${it_var}}" out_len)
        set(${ARGV2} ${out_len} PARENT_SCOPE)
    elseif("${ARGV0}" STREQUAL "SKIP_WHITESPACE")
        if (${ARGC} LESS 2)
            message(FATAL_ERROR "Invalid amount of arguments for operation SKIP_WHITESPACE")
        endif()

        set(iterator_name "${ARGV1}")
        list(FIND ITERATOR_LIST "${iterator_name}" index)

        if (${index} EQUAL -1)
            message(FATAL_ERROR "Iterator ${iterator_name} not found")
        endif()

        iterator_internal_extract(${iterator_name} it_pos it_var)
        string(LENGTH "${${it_var}}" out_len)

        if (NOT ${it_pos} LESS ${out_len})
            return()
        endif()

        math(EXPR out_last_index "${out_len} - 1")

        foreach(i RANGE ${it_pos} ${out_last_index})
            string(SUBSTRING "${${it_var}}" ${i} 1 out_char)

            if (NOT "${out_char}" STREQUAL " ")
                set(${iterator_name} "${i}=${it_var}" PARENT_SCOPE)
                return()
            endif()
        endforeach()

        set(${iterator_name} "${out_len}=${it_var}" PARENT_SCOPE)
    elseif("${ARGV0}" STREQUAL "SKIP_UNTIL")
        if (${ARGC} LESS 3)
            message(FATAL_ERROR "Invalid amount of arguments for operation SKIP_UNTIL")
        endif()

        set(iterator_name "${ARGV1}")
        list(FIND ITERATOR_LIST "${iterator_name}" index)

        if (${index} EQUAL -1)
            message(FATAL_ERROR "Iterator ${iterator_name} not found")
        endif()

        iterator_internal_extract(${iterator_name} it_pos it_var)
        string(LENGTH "${${it_var}}" out_len)

        if (NOT ${it_pos} LESS ${out_len})
            return()
        endif()

        math(EXPR out_last_index "${out_len} - 1")
        set(end_index ${out_last_index})

        if ("${ARGV3}" STREQUAL "REVERSE")
            set(end_index 0)
        endif()

        foreach(i RANGE ${it_pos} ${end_index})
            string(SUBSTRING "${${it_var}}" ${i} 1 out_char)

            if ("${out_char}" STREQUAL "${ARGV2}")
                set(${iterator_name} "${i}=${it_var}" PARENT_SCOPE)
                return()
            endif()
        endforeach()

        if ("${ARGV3}" STREQUAL "REVERSE")
            set(${iterator_name} "0=${it_var}" PARENT_SCOPE)
        else()
            set(${iterator_name} "${out_len}=${it_var}" PARENT_SCOPE)
        endif()
    elseif("${ARGV0}" STREQUAL "PREFIX" OR "${ARGV0}" STREQUAL "SUFFIX")
        if (${ARGC} LESS 3)
            message(FATAL_ERROR "Invalid amount of arguments for operation ${ARGV0}")
        endif()

        set(iterator_name "${ARGV1}")
        list(FIND ITERATOR_LIST "${iterator_name}" index)

        if (${index} EQUAL -1)
            message(FATAL_ERROR "Iterator ${iterator_name} not found")
        endif()

        iterator_internal_extract(${iterator_name} it_pos it_var)
        string(LENGTH "${${it_var}}" out_len)

        if ("${ARGV0}" STREQUAL "PREFIX")
            if (${it_pos} EQUAL 0)
                set(${ARGV2} "" PARENT_SCOPE)
                return()
            endif()

            string(SUBSTRING "${${it_var}}" 0 ${it_pos} out_result)
        else()
            if (${it_pos} EQUAL ${out_len})
                set(${ARGV2} "" PARENT_SCOPE)
                return()
            endif()

            string(SUBSTRING "${${it_var}}" ${it_pos} -1 out_result)
        endif()

        set(${ARGV2} "${out_result}" PARENT_SCOPE)
    else()
        message(FATAL_ERROR "Invalid command ${ARGV0}")
    endif()
endfunction()



########################################################################################################################
# PARSING
########################################################################################################################
function(csv_internal_parse_document prefix input no_header error_header)
    set(record_list  "")
    set(line_number  1)
    set(record_index 0)

    if (no_header)
        set(line_number 2)
    endif()

    foreach(line IN LISTS input)
        if (NOT "${line}" MATCHES "[^ ]+")
            math(EXPR line_number "${line_number} + 1")
            continue()
        endif()

        iterator(CREATE it line)

        set(current_record "")
        set(next_line false)

        set(starts_with_empty_element false)

        while(true)
            iterator(SKIP_WHITESPACE it)

            iterator(PROPERTY POS it field_start)
            iterator(GET it current_char)

            if ("${current_char}" STREQUAL "EOL")
                list(APPEND current_record "")
                break()
            endif()

            if ("${current_char}" STREQUAL "\"")
                iterator(INC it)

                while(true)
                    iterator(SKIP_UNTIL it "\"")
                    iterator(GET it current_char)

                    if ("${current_char}" STREQUAL "EOL")
                        iterator(PROPERTY POS it out_pos)
                        math(EXPR error_pos "${field_start} + 1")
                        message(FATAL_ERROR "${error_header}:${line_number}:${error_pos}: Unterminated quoted string")
                    endif()

                    iterator(GET NEXT it current_char SKIP)

                    if ("${current_char}" STREQUAL "\"")
                        iterator(INC it)
                        continue()
                    endif()

                    if ("${current_char}" STREQUAL " ")
                        iterator(SKIP_WHITESPACE it)
                    endif()

                    if ("${current_char}" STREQUAL "EOL")
                        set(next_line true)

                        iterator(PROPERTY POS it out_pos)
                        math(EXPR element_start "${field_start} + 1")
                        math(EXPR out_pos "${out_pos} - ${element_start} - 1")
                        string(SUBSTRING "${line}" ${element_start} ${out_pos} out_field)
                        string(REPLACE "\"\"" "\"" out_field "${out_field}")

                        if (starts_with_empty_element)
                            set(starts_with_empty_element false)
                            set(current_record            ";${out_field}")
                            break()
                        endif()

                        string(REPLACE ";" "\;" out_field "${out_field}")
                        list(APPEND current_record "${out_field}")
                        break()
                    endif()

                    if ("${current_char}" STREQUAL ",")
                        break()
                    endif()

                    iterator(PROPERTY POS it out_pos)
                    message(FATAL_ERROR "${error_header}:${line_number}:${out_pos}: Invalid character '${current_char}' after terminated quoted string, expected comma or EOL")
                endwhile()

                if (next_line)
                    break()
                endif()

                iterator(PROPERTY POS it out_pos)
                math(EXPR element_length "${out_pos} - ${field_start}")
                string(SUBSTRING "${line}" ${field_start} ${element_length} out_field)
                string(REPLACE "\"\"" "\"" out_field "${out_field}")

                string(REPLACE ";" "\;" out_field "${out_field}")

                if ("${out_field}" MATCHES [=[^[ ]*"(.*)"[ ]*$]=])
                    if (starts_with_empty_element)
                        set(starts_with_empty_element false)
                        set(current_record            ";${CMAKE_MATCH_1}")
                    else()
                        list(APPEND current_record "${CMAKE_MATCH_1}")
                    endif()
                endif()

                iterator(GET NEXT it current_char SKIP)

                if ("${current_char}" STREQUAL "EOL")
                    break()
                endif()

                continue()
            endif()

            if ("${current_char}" STREQUAL ",")
                iterator(INC it)

                if (starts_with_empty_element)
                    set(starts_with_empty_element false)
                    set(current_record ";")
                    continue()
                endif()

                list(APPEND current_record "")

                if ("${current_record}" STREQUAL "")
                    set(starts_with_empty_element true)
                endif()

                continue()
            endif()

            iterator(SKIP_UNTIL it ",")
            iterator(PROPERTY POS it out_pos)

            math(EXPR element_length "${out_pos} - ${field_start}")

            string(SUBSTRING "${line}" ${field_start} ${element_length} out_field)
            string(FIND "${out_field}" "\"" invalid_quote_pos)

            if (${invalid_quote_pos} GREATER -1)
                string(LENGTH "${out_field}" st_len)
                math(EXPR invalid_quote_pos "${field_start} + ${invalid_quote_pos} + 1")
                message(FATAL_ERROR "${error_header}:${line_number}:${invalid_quote_pos}: Invalid character '\"' in unquoted string")
            endif()

            string(STRIP "${out_field}" out_field)
            string(REPLACE ";" "\;" out_field "${out_field}")

            if (starts_with_empty_element)
                set(starts_with_empty_element false)
                set(current_record            ";${out_field}")
            else()
                list(APPEND current_record "${out_field}")
            endif()

            iterator(GET it current_char)

            if ("${current_char}" STREQUAL "EOL")
                break()
            endif()

            iterator(INC it)
        endwhile()

        math(EXPR line_number  "${line_number} + 1")
        math(EXPR record_index "${record_index} + 1")

        set(record_name ${prefix}_RECORD_${record_index})
        list(APPEND record_list ${record_name})

        set(${record_name} "${current_record}" PARENT_SCOPE)

        iterator(DELETE it)
    endforeach()

    set(${prefix} ${record_list} PARENT_SCOPE)
endfunction()



########################################################################################################################
# PUBLIC
########################################################################################################################
function(csv operation)
    if ("${operation}" STREQUAL "IMPORT")
        csv_internal_need_at_least(${operation} ${ARGC} 4)

        set(prefix ${ARGV1})
        set(method ${ARGV2})
        set(input  ${ARGV3})

        get_property(document_list GLOBAL
            PROPERTY es_csv_parser_document_list)

        if ("${prefix}" IN_LIST document_list)
            message(FATAL_ERROR "There has already been registered a csv document for prefix '${prefix}'")
        endif()

        cmake_parse_arguments(PARSE_ARGV 4 PARG "STRICT" "HEADER" "")
        set(IGNORE_HEADER false)

        if (DEFINED PARG_HEADER AND NOT "PARG_HEADER" IN_LIST PARG_KEYWORDS_MISSING_VALUES
            AND NOT "${PARG_HEADER}" STREQUAL "NORMAL")
            if("${PARG_HEADER}" STREQUAL "IGNORE")
                set(IGNORE_HEADER true)
            elseif(NOT "${PARG_HEADER}" STREQUAL "PARSE")
                message(FATAL_ERROR "Invalid HEADER mode '${PARG_HEADER}', allowed are PARSE and IGNORE")
            endif()
        endif()

        if ("${method}" STREQUAL "FILE")
            if (NOT EXISTS "${input}")
                message(FATAL_ERROR "Could not read csv file, it doesn't exist (File '${input}')")
            endif()

            file(READ "${input}" CSV_DATA)

            string(REPLACE ";" "\\\;" CSV_DATA "${CSV_DATA}")
            string(REPLACE "\n" ";" CSV_DATA "${CSV_DATA}")

            if (${IGNORE_HEADER})
                list(POP_FRONT CSV_DATA)
            endif()

            get_filename_component(out_file_name "${input}" NAME)
            csv_internal_parse_document(${prefix} "${CSV_DATA}" ${IGNORE_HEADER} "${out_file_name}")
        elseif("${method}" STREQUAL "STRING")
            string(REPLACE ";" "\\\;" CSV_DATA "${input}")
            string(REPLACE "\n" ";" CSV_DATA "${CSV_DATA}")

            if (${IGNORE_HEADER})
                list(POP_FRONT CSV_DATA)
            endif()

            csv_internal_parse_document(${prefix} "${CSV_DATA}" ${IGNORE_HEADER} "string")
        endif()

        set(column_count 0)

        foreach (record IN LISTS ${prefix})
            list(LENGTH ${record} rec_len)

            if (PARG_STRICT AND ${column_count} GREATER 0 AND NOT ${rec_len} EQUAL ${column_count})
                message(FATAL_ERROR "Record lengths are not uniform, STRICT mode disallows variable length records (Record: ${${record}})")
            endif()

            if (${rec_len} GREATER ${column_count})
                set(column_count ${rec_len})
            endif()
        endforeach()

        if (DEFINED PARG_HEADER AND "${PARG_HEADER}" STREQUAL "PARSE")
            list(POP_FRONT ${prefix})
            math(EXPR end_index "${column_count} - 1")

            list(LENGTH ${prefix}_RECORD_1 header_len)

            foreach(i RANGE ${end_index})
                if (${i} LESS ${header_len})
                    list(GET ${prefix}_RECORD_1 ${i} out_header_name)
                    string(REPLACE ";" "\;" out_header_name "${out_header_name}")
                    list(APPEND header_list "${out_header_name}")
                else()
                    math(EXPR out_indexer "${i} + 1")
                    list(APPEND header_list ${out_indexer})
                endif()
            endforeach()
        else()
            foreach(i RANGE 1 ${column_count})
                list(APPEND header_list ${i})
            endforeach()
        endif()

        set(${prefix}_HEADERS "${header_list}" PARENT_SCOPE)

        list(LENGTH ${prefix}_DOCUMENT out_len)
        set(record_index_i 1)

        foreach(record IN LISTS ${prefix})
            list(LENGTH ${record} rec_len)
            math(EXPR needed_len "${column_count} - ${rec_len}")

            if (${needed_len} GREATER 0)
                if (${rec_len} EQUAL 0)
                    foreach(i RANGE 1 ${needed_len})
                        if (${i} EQUAL 1)
                            continue()
                        endif()

                        string(APPEND ${record} ";")
                    endforeach()
                else()
                    foreach(i RANGE 1 ${needed_len})
                        list(APPEND ${record} "")
                    endforeach()
                endif()
            endif()

            set(${prefix}_RECORD_${record_index_i} "${${record}}" PARENT_SCOPE)
            math(EXPR record_index_i "${record_index_i} + 1")
        endforeach()

        if (DEFINED PARG_HEADER AND "${PARG_HEADER}" STREQUAL "PARSE")
            list(POP_BACK ${prefix})
            list(PREPEND ${prefix} ${prefix}_RECORD_1)
        endif()

        set(${prefix}_DOCUMENT "${${prefix}}" PARENT_SCOPE)
        set(${prefix}_COLUMN_COUNT ${column_count} PARENT_SCOPE)

        set_property(GLOBAL APPEND
            PROPERTY es_csv_parser_document_list "${prefix}")
    elseif ("${operation}" STREQUAL "GET")
        csv_internal_need_at_least(${operation} ${ARGC} 3)

        set(prefix  ${ARGV1})
        set(out_var ${ARGV2})

        csv_internal_document_check()
        cmake_parse_arguments(PARSE_ARGV 3 PARG "" "RECORD;COLUMN" "")

        set(record_to_get 0)
        set(field_to_get  0)

        if (DEFINED PARG_RECORD AND NOT "PARG_RECORD" IN_LIST PARG_KEYWORDS_MISSING_VALUES)
            set(record_to_get ${PARG_RECORD})

            if (NOT "${record_to_get}" MATCHES "0|[1-9][0-9]*")
                message(FATAL_ERROR "Invalid RECORD ordinal '${record_to_get}', not a number")
            endif()

            if (${record_to_get} LESS 1)
                message(FATAL_ERROR "Invalid RECORD ordinal '${record_to_get}', must be greater than 0")
            endif()
        endif()

        if (DEFINED PARG_COLUMN AND NOT "PARG_COLUMN" IN_LIST PARG_KEYWORDS_MISSING_VALUES)
            set(field_to_get ${PARG_COLUMN})

            if (NOT "${field_to_get}" MATCHES "0|[1-9][0-9]*")
                message(FATAL_ERROR "Invalid COLUMN ordinal '${field_to_get}', not a number")
            endif()

            if (${field_to_get} LESS 1)
                message(FATAL_ERROR "Invalid COLUMN ordinal '${field_to_get}', must be greater than 0")
            endif()
        endif()

        # At least FIELD or RECORD needs to be specified
        if (${record_to_get} LESS 1 AND ${field_to_get} LESS 1)
            message(FATAL_ERROR "Operation GET called without COLUMN and RECORD, at least one needs to be specified")

            # Get list of fields in a record
        elseif (${record_to_get} GREATER 0 AND ${field_to_get} LESS 1)
            list(LENGTH ${prefix}_DOCUMENT out_len)

            if (${record_to_get} GREATER ${out_len})
                message(FATAL_ERROR "Record ordinal out of bounds '${record_to_get}', last record is ${out_len}")
            endif()

            set(${out_var} "${${prefix}_RECORD_${record_to_get}}" PARENT_SCOPE)

            # Get list of field values in a whole column
        elseif (${record_to_get} LESS 1 AND ${field_to_get} GREATER 0)
            if (${field_to_get} GREATER ${${prefix}_COLUMN_COUNT})
                message(FATAL_ERROR "Column ordinal '${field_to_get}' out of bounds, last field number is ${${prefix}_COLUMN_COUNT}")
            endif()

            set(starts_with_empty_field false)

            foreach(record IN LISTS ${prefix}_DOCUMENT)
                math(EXPR index "${field_to_get} - 1")
                list(GET ${record} ${index} out_value)

                if ("${record}" STREQUAL "${prefix}_RECORD_1" AND NOT "${out_value}" MATCHES "[^ ]+")
                    set(starts_with_empty_field true)
                    continue()
                endif()

                if (starts_with_empty_field)
                    set(field_list ";${out_value}")
                    set(starts_with_empty_field false)
                    continue()
                endif()

                list(APPEND field_list "${out_value}")
            endforeach()

            set(${out_var} "${field_list}" PARENT_SCOPE)

            # Get specific field from specific record
        else()
            list(LENGTH ${prefix}_DOCUMENT doc_len)

            if (${record_to_get} GREATER ${doc_len})
                message(FATAL_ERROR "Record ordinal '${record_to_get}' out of bounds, last record is ${doc_len}")
            endif()

            if (${field_to_get} GREATER ${${prefix}_COLUMN_COUNT})
                message(FATAL_ERROR "Column ordinal '${field_to_get}' out of bounds, last column is ${${prefix}_COLUMN_COUNT}")
            endif()

            math(EXPR field_index "${field_to_get} - 1")
            list(GET ${prefix}_RECORD_${record_to_get} ${field_index} out_field)

            set(${out_var} "${out_field}" PARENT_SCOPE)
        endif()
    elseif ("${operation}" STREQUAL "REMOVE")
        csv_internal_need_at_least(${operation} ${ARGC} 2)

        set(prefix ${ARGV1})

        csv_internal_document_check()

        if (NOT "${prefix}" IN_LIST document_list)
            message(FATAL_ERROR "There is no registered csv document for prefix '${prefix}'")
        endif()

        cmake_parse_arguments(PARSE_ARGV 2 PARG "" "COLUMN;RECORD;OUTPUT_VARIABLE" "")

        set(record_to_get 0)
        set(field_to_get  0)

        if (DEFINED PARG_RECORD AND NOT "PARG_RECORD" IN_LIST PARG_KEYWORDS_MISSING_VALUES)
            set(record_to_get ${PARG_RECORD})

            if (NOT "${record_to_get}" MATCHES "0|[1-9][0-9]*")
                message(FATAL_ERROR "Invalid RECORD ordinal '${record_to_get}', not a number")
            endif()

            if (${record_to_get} LESS 1)
                message(FATAL_ERROR "Invalid RECORD ordinal '${record_to_get}', must be greater than 0")
            endif()
        endif()

        if (DEFINED PARG_COLUMN AND NOT "PARG_COLUMN" IN_LIST PARG_KEYWORDS_MISSING_VALUES)
            set(field_to_get ${PARG_COLUMN})

            if (NOT "${field_to_get}" MATCHES "0|[1-9][0-9]*")
                message(FATAL_ERROR "Invalid COLUMN ordinal '${field_to_get}', not a number")
            endif()

            if (${field_to_get} LESS 1)
                message(FATAL_ERROR "Invalid COLUMN ordinal '${field_to_get}', must be greater than 0")
            endif()
        endif()

        if (DEFINED PARG_OUTPUT_VARIABLE AND NOT "PARG_OUTPUT_VARIABLE" IN_LIST PARG_KEYWORDS_MISSING_VALUES)
            set(output_var "${PARG_OUTPUT_VARIABLE}")
        endif()

        # At least FIELD or RECORD needs to be specified
        if (${record_to_get} LESS 1 AND ${field_to_get} LESS 1)
            message(FATAL_ERROR "Operation GET called without COLUMN and RECORD, at least one needs to be specified")

            # Remove record
        elseif (${record_to_get} GREATER 0 AND ${field_to_get} LESS 1)
            list(LENGTH ${prefix}_DOCUMENT out_len)

            if (${record_to_get} GREATER ${out_len})
                message(FATAL_ERROR "Record ordinal out of bounds '${record_to_get}', last record is ${out_len}")
            endif()

            math(EXPR rec_index "${record_to_get} - 1")
            list(SUBLIST ${prefix}_DOCUMENT 0 ${rec_index} new_document_list)

            if (DEFINED output_var)
                list(GET ${prefix}_DOCUMENT ${rec_index} record_to_remove)
                set(${output_var} "${${record_to_remove}}" PARENT_SCOPE)
            endif()

            math(EXPR new_last_index "${out_len} - 2")
            list(REMOVE_AT ${prefix}_DOCUMENT ${rec_index})

            if (${rec_index} LESS_EQUAL ${new_last_index})
                foreach(i RANGE ${rec_index} ${new_last_index})
                    list(GET ${prefix}_DOCUMENT ${i} out_record)
                    set(record_temp "${${out_record}}")

                    math(EXPR new_ordinal "${i} + 1")
                    set(${prefix}_RECORD_${new_ordinal} "${record_temp}" PARENT_SCOPE)
                    list(APPEND new_document_list ${prefix}_RECORD_${new_ordinal})
                endforeach()
            endif()

            unset(${prefix}_RECORD_${out_len} PARENT_SCOPE)
            set(${prefix}_DOCUMENT ${new_document_list} PARENT_SCOPE)

            # Remove an entire column
        elseif (${record_to_get} LESS 1 AND ${field_to_get} GREATER 0)
            if (${${prefix}_COLUMN_COUNT} EQUAL 0)
                message(FATAL_ERROR "No column could be removed as there is none")
            endif()

            if (${field_to_get} GREATER ${${prefix}_COLUMN_COUNT})
                message(FATAL_ERROR "Column ordinal '${field_to_get}' out of bounds, last column number is ${${prefix}_COLUMN_COUNT}")
            endif()

            if (${${prefix}_COLUMN_COUNT} EQUAL 1)
                foreach(record IN LISTS ${prefix}_DOCUMENT)
                    list(APPEND removed_values "${${record}}")
                    set(${record} "" PARENT_SCOPE)
                endforeach()

                set(${prefix}_HEADERS 1 PARENT_SCOPE)
            else()
                math(EXPR column_index "${field_to_get} - 1")

                foreach(record IN LISTS ${prefix}_DOCUMENT)
                    list(GET ${record} ${column_index} value_to_remove)
                    list(APPEND removed_values "${value_to_remove}")

                    string(REPLACE "\;" "\\\;" ${record} "${${record}}")
                    list(REMOVE_AT ${record} ${column_index})
                    set(${record} "${${record}}" PARENT_SCOPE)
                endforeach()

                list(GET ${prefix}_HEADERS ${column_index} header_to_remove)

                string(REPLACE "\;" "\\\;" ${prefix}_HEADERS "${${prefix}_HEADERS}")
                list(REMOVE_AT ${prefix}_HEADERS ${column_index})
                set(${prefix}_HEADERS "${${prefix}_HEADERS}" PARENT_SCOPE)
            endif()

            math(EXPR new_column_count "${${prefix}_COLUMN_COUNT} - 1")
            set(${prefix}_COLUMN_COUNT ${new_column_count} PARENT_SCOPE)

            if (DEFINED output_var)
                set(${output_var} "${removed_values}")
                list(PREPEND ${output_var} "${header_to_remove}")

                set(${output_var} "${${output_var}}" PARENT_SCOPE)
            endif()

            # Reset certain field
        else()
            list(LENGTH ${prefix}_DOCUMENT doc_len)

            if (${record_to_get} GREATER ${doc_len})
                message(FATAL_ERROR "Record ordinal '${record_to_get}' out of bounds, last record is ${doc_len}")
            endif()

            if (${field_to_get} GREATER ${${prefix}_COLUMN_COUNT})
                message(FATAL_ERROR "Column ordinal '${field_to_get}' out of bounds, last column is ${${prefix}_COLUMN_COUNT}")
            endif()

            math(EXPR field_index "${field_to_get} - 1")

            if (DEFINED output_var)
                list(GET ${prefix}_RECORD_${record_to_get} ${field_index} value_to_remove)
                set(${output_var} "${value_to_remove}" PARENT_SCOPE)
            endif()

            string(REPLACE "\;" "\\\;" ${prefix}_RECORD_${record_to_get} "${${prefix}_RECORD_${record_to_get}}")
            list(REMOVE_AT ${prefix}_RECORD_${record_to_get} ${field_index})

            string(REPLACE "\;" "\\\;" ${prefix}_RECORD_${record_to_get} "${${prefix}_RECORD_${record_to_get}}")
            list(INSERT ${prefix}_RECORD_${record_to_get} ${field_index} "")

            set(${prefix}_RECORD_${record_to_get} "${${prefix}_RECORD_${record_to_get}}" PARENT_SCOPE)
        endif()
    elseif ("${operation}" STREQUAL "SET")
        csv_internal_need_at_least(${operation} ${ARGC} 4)

        set(prefix ${ARGV1})
        set(record ${ARGV2})
        set(field  ${ARGV3})

        csv_internal_document_check()
        list(LENGTH ${prefix}_DOCUMENT doc_len)

        if (NOT "${record}" MATCHES "0|[1-9][0-9]*")
            message(FATAL_ERROR "Invalid RECORD ordinal '${record}', not a number")
        endif()

        if (${record} LESS 1)
            message(FATAL_ERROR "Invalid RECORD ordinal '${record}', must be greater than 0")
        endif()

        if (NOT "${field}" MATCHES "0|[1-9][0-9]*")
            message(FATAL_ERROR "Invalid COLUMN ordinal '${field}', not a number")
        endif()

        if (${field} LESS 1)
            message(FATAL_ERROR "Invalid COLUMN ordinal '${field}', must be greater than 0")
        endif()

        if (${record} GREATER ${doc_len})
            message(FATAL_ERROR "Record ordinal '${record}' out of bounds, last record is ${doc_len}")
        endif()

        if (${field} GREATER ${${prefix}_COLUMN_COUNT})
            message(FATAL_ERROR "Column ordinal '${field}' out of bounds, last column is ${${prefix}_COLUMN_COUNT}")
        endif()

        math(EXPR field "${field} - 1")

        string(REPLACE "\;" "\\\;" ${prefix}_RECORD_${record} "${${prefix}_RECORD_${record}}")
        list(REMOVE_AT ${prefix}_RECORD_${record} ${field})

        string(REPLACE "\;" "\\\;" ${prefix}_RECORD_${record} "${${prefix}_RECORD_${record}}")
        list(INSERT    ${prefix}_RECORD_${record} ${field} "${value}")

        set(${prefix}_RECORD_${record} "${${prefix}_RECORD_${record}}" PARENT_SCOPE)
    elseif ("${operation}" STREQUAL "INSERT")
        csv_internal_need_at_least(${operation} ${ARGC} 3)

        set(type   ${ARGV1})
        set(prefix ${ARGV2})

        csv_internal_document_check()

        set(ov_args   POSITION FILL)
        set(list_args VALUES)

        if ("${type}" STREQUAL "RECORD")
            list(APPEND ov_args "HEADER")
        elseif (NOT "${type}" STREQUAL "COLUMN")
            message(FATAL_ERROR "Invalid entity type '${type}' for operation 'INSERT'")
        endif()

        cmake_parse_arguments(PARSE_ARGV 3 PARG "" "${ov_args}" "${list_args}")
        set(index_to_insert -1)

        if (DEFINED PARG_POSITION AND NOT "PARG_POSITION" IN_LIST PARG_KEYWORDS_MISSING_VALUES)
            set(index_to_insert "${PARG_POSITION}")

            if (NOT "${index_to_insert}" MATCHES "[0]|[1-9][0-9]*")
                message(FATAL_ERROR "Position '${PARG_POSITION}' not a number")
            endif()

            math(EXPR index_to_insert "${index_to_insert} - 1")

            if (${index_to_insert} LESS 0)
                message(FATAL_ERROR "Insert position out of bounds: ${PARG_POSITION}")
            endif()
        endif()

        set(value_list       "")
        set(value_list_empty true)

        if (DEFINED PARG_VALUES AND NOT "PARG_VALUES" IN_LIST PARG_KEYWORDS_MISSING_VALUES)
            set(value_list "${PARG_VALUES}")
            set(value_list_empty false)
        endif()

        set(fill "")

        if (DEFINED PARG_FILL AND NOT "PARG_FILL" IN_LIST PARG_KEYWORDS_MISSING_VALUES)
            set(fill "${PARG_FILL}")
        endif()

        if ("${type}" STREQUAL "RECORD")
            list(LENGTH ${prefix}_DOCUMENT out_len)

            if (${index_to_insert} LESS -1 OR ${index_to_insert} GREATER ${out_len})
                message(FATAL_ERROR "Insert position out of bounds: ${PARG_POSITION}")
            endif()

            if (${index_to_insert} EQUAL -1)
                set(index_to_insert ${out_len})
            endif()

            set(new_document_list "${${prefix}_DOCUMENT}")

            if (${index_to_insert} LESS ${out_len})
                list(SUBLIST ${prefix}_DOCUMENT 0 ${index_to_insert} new_document_list)
                math(EXPR doc_last_index "${out_len} - 1")

                foreach(i RANGE ${index_to_insert} ${doc_last_index})
                    list(GET ${prefix}_DOCUMENT ${i} out_record)
                    set(record_temp "${${out_record}}")

                    math(EXPR new_ordinal "${i} + 2")
                    set(_RECORD_${new_ordinal} "${record_temp}")
                    list(APPEND temp_records _RECORD_${new_ordinal})
                    list(APPEND new_document_list ${prefix}_RECORD_${new_ordinal})
                endforeach()

                foreach(record IN LISTS temp_records)
                    set(${prefix}${record} "${${record}}" PARENT_SCOPE)
                endforeach()
            endif()

            math(EXPR ordinal "${index_to_insert} + 1")
            list(INSERT new_document_list ${index_to_insert} "${prefix}_RECORD_${ordinal}")

            if (${${prefix}_COLUMN_COUNT} GREATER 0)
                csv_internal_INSERT_create_record("${value_list}" ${${prefix}_COLUMN_COUNT} new_record "${fill}")
                set(${prefix}_RECORD_${ordinal} "${new_record}" PARENT_SCOPE)
            else()
                set(${prefix}_RECORD_${ordinal} "" PARENT_SCOPE)
            endif()

            set(${prefix}_DOCUMENT "${new_document_list}" PARENT_SCOPE)
        else()
            set(out_len ${${prefix}_COLUMN_COUNT})

            if (${index_to_insert} LESS -1 OR ${index_to_insert} GREATER ${out_len})
                message(FATAL_ERROR "Insert position out of bounds: ${PARG_POSITION}")
            endif()

            if (${index_to_insert} EQUAL -1)
                set(header_name ${out_len})
                set(index_to_insert ${out_len})
            endif()

            if (DEFINED PARG_HEADER AND NOT "PARG_HEADER" IN_LIST PARG_KEYWORDS_MISSING_VALUES)
                set(header_name "${PARG_HEADER}")
            else()
                math(EXPR header_name "${index_to_insert} + 1")
            endif()

            list(LENGTH ${prefix}_DOCUMENT doc_len)

            if (${doc_len} GREATER 0)
                if (${out_len} EQUAL 0)
                    list(LENGTH ${prefix}_DOCUMENT doc_len)
                    math(EXPR last_doc_index "${doc_len} - 1")

                    list(LENGTH value_list out_values_len)
                    set(compensate false)

                    if (${out_values_len} EQUAL 0 AND NOT value_list_empty)
                        set(out_values_len 1)
                        set(compensate true)
                    endif()

                    foreach(i RANGE ${last_doc_index})
                        list(GET ${prefix}_DOCUMENT ${i} out_record)
                        set(value "${fill}")

                        if (compensate)
                            set(value "")
                            set(compensate false)
                        elseif (${i} LESS ${out_values_len})
                            list(GET value_list ${i} value)
                        endif()

                        set(${out_record} "${value}" PARENT_SCOPE)
                    endforeach()
                elseif(${${prefix}_COLUMN_COUNT} EQUAL 1)
                    list(LENGTH ${prefix}_DOCUMENT doc_len)
                    math(EXPR last_doc_index "${doc_len} - 1")

                    list(LENGTH value_list out_values_len)
                    set(compensate false)

                    if (${out_values_len} EQUAL 0 AND NOT value_list_empty)
                        set(out_values_len 1)
                        set(compensate true)
                    endif()

                    foreach(i RANGE ${last_doc_index})
                        list(GET ${prefix}_DOCUMENT ${i} out_record)
                        set(value "${fill}")

                        if (compensate)
                            set(value "")
                            set(compensate false)
                        elseif (${i} LESS ${out_values_len})
                            list(GET value_list ${i} value)
                        endif()

                        if (${index_to_insert} EQUAL 0)
                            set(${out_record} "${value};${${out_record}}" PARENT_SCOPE)
                        else()
                            set(${out_record} "${${out_record}};${value}" PARENT_SCOPE)
                        endif()
                    endforeach()
                else()
                    list(LENGTH ${prefix}_DOCUMENT doc_len)
                    math(EXPR last_doc_index "${doc_len} - 1")

                    list(LENGTH value_list out_values_len)
                    set(compensate false)

                    if (${out_values_len} EQUAL 0 AND NOT value_list_empty)
                        set(out_values_len 1)
                        set(compensate true)
                    endif()

                    foreach(i RANGE ${last_doc_index})
                        list(GET ${prefix}_DOCUMENT ${i} out_record)
                        set(value "${fill}")

                        if (compensate)
                            set(value "")
                            set(compensate false)
                        elseif (${i} LESS ${out_values_len})
                            list(GET value_list ${i} value)
                        endif()

                        string(REPLACE "\;" "\\\;" ${out_record} "${${out_record}}")
                        list(INSERT ${out_record} ${index_to_insert} "${value}")
                        set(${out_record} "${${out_record}}" PARENT_SCOPE)
                    endforeach()
                endif()
            endif()

            string(REPLACE "\;" "\\\;" ${prefix}_HEADERS "${${prefix}_HEADERS}")
            list(INSERT ${prefix}_HEADERS ${index_to_insert} "${header_name}")
            set(${prefix}_HEADERS "${${prefix}_HEADERS}" PARENT_SCOPE)

            math(EXPR column_count "${${prefix}_COLUMN_COUNT} + 1")
            set(${prefix}_COLUMN_COUNT ${column_count} PARENT_SCOPE)
        endif()
    elseif ("${operation}" STREQUAL "CREATE")
        csv_internal_need_at_least(${operation} ${ARGC} 2)

        set(prefix ${ARGV1})

        get_property(document_list GLOBAL
            PROPERTY es_csv_parser_document_list)

        if ("${prefix}" IN_LIST document_list)
            message(FATAL_ERROR "There has already been registered a csv document for prefix '${prefix}'")
        endif()

        set(${prefix}_DOCUMENT     "" PARENT_SCOPE)
        set(${prefix}_COLUMN_COUNT 0  PARENT_SCOPE)
        set(${prefix}_HEADERS      "" PARENT_SCOPE)

        set_property(GLOBAL APPEND
            PROPERTY es_csv_parser_document_list
            "${prefix}")
    elseif ("${operation}" STREQUAL "DELETE")
        csv_internal_need_at_least(${operation} ${ARGC} 2)

        set(prefix ${ARGV1})

        csv_internal_document_check()

        foreach(record IN LISTS ${prefix}_DOCUMENT)
            unset(${record} PARENT_SCOPE)
        endforeach()

        unset(${prefix}_DOCUMENT     PARENT_SCOPE)
        unset(${prefix}_COLUMN_COUNT PARENT_SCOPE)
        unset(${prefix}_HEADERS      PARENT_SCOPE)

        get_property(document_list GLOBAL
            PROPERTY es_csv_parser_document_list)

        list(REMOVE_ITEM document_list "${prefix}")
        set_property(GLOBAL
            PROPERTY es_csv_parser_document_list
            "${document_list}")
    elseif ("${operation}" STREQUAL "MOVE")
        csv_internal_need_at_least(${operation} ${ARGC} 5)

        set(type    ${ARGV1})
        set(prefix  ${ARGV2})
        set(ordinal ${ARGV3})
        set(mode    ${ARGV4})
        set(value   1)

        csv_internal_document_check()
        list(LENGTH ${prefix}_DOCUMENT doc_len)
        set(col_len ${${prefix}_COLUMN_COUNT})

        if ("${type}" STREQUAL "RECORD")
            set(modes UP DOWN)

            if ("${mode}" IN_LIST modes)
                if (${ARGC} GREATER 5)
                    set(value "${ARGV5}")

                    if (NOT "${value}" MATCHES "[0]|[1-9][0-9]*")
                        message(FATAL_ERROR "Invalid move amount '${value}', not a number")
                    endif()
                endif()

                if ("${mode}" STREQUAL "UP")
                    math(EXPR value "${ordinal} - ${value}")

                    if (${value} LESS 1)
                        message(FATAL_ERROR "Invalid amount, new position is out of bounds '${value}'")
                    endif()
                else()
                    math(EXPR value "${ordinal} + ${value}")

                    if (${value} GREATER ${doc_len})
                        message(FATAL_ERROR "Invalid amount, new position is out of bounds '${value}'")
                    endif()
                endif()
            elseif("${mode}" STREQUAL "POSITION")
                if (${ARGC} LESS 6)
                    message(FATAL_ERROR "MOVE mode 'POSITION' needs an ordinal argument")
                endif()

                set(value "${ARGV5}")

                if (NOT "${value}" MATCHES "[0]|[1-9][0-9]*")
                    message(FATAL_ERROR "Invalid position '${value}', not a number")
                endif()

                if (${value} LESS 1 OR ${value} GREATER doc_len)
                    message(FATAL_ERROR "Position '${value}' out of bounds")
                endif()

                if (${value} EQUAL ${ordinal})
                    return()
                endif()
            else()
                message(FATAL_ERROR "Invalid MOVE mode '${mode}' for type '${type}'")
            endif()

            csv(REMOVE ${prefix}
                RECORD          ${ordinal}
                OUTPUT_VARIABLE record_val)

            csv(INSERT RECORD ${prefix}
                POSITION ${value}
                VALUES   ${record_val})

            set(${prefix}_DOCUMENT "${${prefix}_DOCUMENT}" PARENT_SCOPE)

            foreach(record IN LISTS ${prefix}_DOCUMENT)
                set(${record} "${${record}}" PARENT_SCOPE)
            endforeach()
        elseif("${type}" STREQUAL "COLUMN")
            set(modes LEFT RIGHT)

            if ("${mode}" IN_LIST modes)
                if (${ARGC} GREATER 5)
                    set(value "${ARGV5}")

                    if (NOT "${value}" MATCHES "[0]|[1-9][0-9]*")
                        message(FATAL_ERROR "Invalid move amount '${value}', not a number")
                    endif()
                endif()

                if ("${mode}" STREQUAL "LEFT")
                    math(EXPR value "${ordinal} - ${value}")

                    if (${value} LESS 1)
                        message(FATAL_ERROR "Invalid amount, new position is out of bounds '${value}'")
                    endif()
                else()
                    math(EXPR value "${ordinal} + ${value}")

                    if (${value} GREATER ${col_len})
                        message(FATAL_ERROR "Invalid amount, new position is out of bounds '${value}'")
                    endif()
                endif()
            elseif("${mode}" STREQUAL "POSITION")
                if (${ARGC} LESS 6)
                    message(FATAL_ERROR "MOVE mode 'POSITION' needs an ordinal argument")
                endif()

                set(value "${ARGV5}")

                if (NOT "${value}" MATCHES "[0]|[1-9][0-9]*")
                    message(FATAL_ERROR "Invalid position '${value}', not a number")
                endif()

                if (${value} LESS 1 OR ${value} GREATER col_len)
                    message(FATAL_ERROR "Position '${value}' out of bounds")
                endif()

                if (${value} EQUAL ${ordinal})
                    return()
                endif()
            else()
                message(FATAL_ERROR "Invalid MOVE mode '${mode}' for type '${type}'")
            endif()

            csv(REMOVE ${prefix}
                COLUMN          ${ordinal}
                OUTPUT_VARIABLE record_val)

            list(POP_FRONT record_val out_header_name)

            csv(INSERT COLUMN ${prefix}
                POSITION ${value}
                VALUES   ${record_val}
                HEADER   "${out_header_name}")

            set(${prefix}_DOCUMENT "${${prefix}_DOCUMENT}" PARENT_SCOPE)
            set(${prefix}_HEADERS  "${${prefix}_HEADERS}"  PARENT_SCOPE)

            foreach(record IN LISTS ${prefix}_DOCUMENT)
                set(${record} "${${record}}" PARENT_SCOPE)
            endforeach()
        else()
            message(FATAL_ERROR "Invalid entity '${type}' for operation 'MOVE'")
        endif()
    elseif("${operation}" STREQUAL "EXPORT")
        csv_internal_need_at_least(${operation} ${ARGC} 4)

        set(prefix ${ARGV1})
        set(method ${ARGV2})
        set(output ${ARGV3})

        csv_internal_document_check()

        cmake_parse_arguments(PARSE_ARGV 4 PARG "" "HEADER" "")
        set(include_header false)

        if (DEFINED PARG_HEADER AND NOT "PARG_HEADER" IN_LIST PARG_KEYWORDS_MISSING_VALUES
            AND NOT "${PARG_HEADER}" STREQUAL "EXCLUDE")
            if("${PARG_HEADER}" STREQUAL "INCLUDE")
                set(include_header true)
            elseif(NOT "${PARG_HEADER}" STREQUAL "PARSE")
                message(FATAL_ERROR "Invalid HEADER mode '${PARG_HEADER}', allowed are PARSE and IGNORE")
            endif()
        endif()

        if (${include_header})
            csv_internal_format_record("${${prefix}_HEADERS}" output_text)
        endif()

        foreach(record IN LISTS ${prefix}_DOCUMENT)
            csv_internal_format_record("${${record}}" line)
            string(APPEND output_text "${line}")
        endforeach()

        if ("${method}" STREQUAL "FILE")
            file(WRITE "${output}" "${output_text}")
        elseif("${method}" STREQUAL "STRING")
            string(REPLACE ";" "\;" output_text "${output_text}")
            set(${output} "${output_text}" PARENT_SCOPE)
        endif()
    elseif("${operation}" STREQUAL "GET_HEADER")
        csv_internal_need_at_least(${operation} ${ARGC} 4)

        set(prefix  ${ARGV1})
        set(ordinal ${ARGV2})
        set(output  ${ARGV3})

        csv_internal_document_check()

        if (NOT "${ordinal}" MATCHES "[0]|[1-9][0-9]*")
            message(FATAL_ERROR "Invalid ordinal '${ordinal}', not a number")
        endif()

        if (${ordinal} LESS 1 OR ${ordinal} GREATER ${${prefix}_COLUMN_COUNT})
            message(FATAL_ERROR "Invalid ordinal '${ordinal}', out of bounds")
        endif()

        math(EXPR index "${ordinal} - 1")
        list(GET ${prefix}_HEADERS ${index} out_header_name)
        string(REPLACE ";" "\;" out_header_name "${out_header_name}")
        set(${output} "${out_header_name}" PARENT_SCOPE)
    elseif("${operation}" STREQUAL "SET_HEADER")
        csv_internal_need_at_least(${operation} ${ARGC} 4)

        set(prefix  ${ARGV1})
        set(ordinal ${ARGV2})
        set(input   ${ARGV3})

        csv_internal_document_check()

        if (NOT "${ordinal}" MATCHES "[0]|[1-9][0-9]*")
            message(FATAL_ERROR "Invalid ordinal '${ordinal}', not a number")
        endif()

        if (${ordinal} LESS 1 OR ${ordinal} GREATER ${${prefix}_COLUMN_COUNT})
            message(FATAL_ERROR "Invalid ordinal '${ordinal}', out of bounds")
        endif()

        math(EXPR index "${ordinal} - 1")
        string(REPLACE "\;" "\\\;" ${prefix}_HEADERS "${${prefix}_HEADERS}")
        list(REMOVE_AT ${prefix}_HEADERS ${index})

        string(REPLACE "\;" "\\\;" ${prefix}_HEADERS "${${prefix}_HEADERS}")
        string(REPLACE ";" "\;" input "${input}")
        list(INSERT ${prefix}_HEADERS ${index} "${input}")

        set(${prefix}_HEADERS "${${prefix}_HEADERS}" PARENT_SCOPE)
    else()
        message(FATAL_ERROR "Invalid operation ${operation}")
    endif()
endfunction()
